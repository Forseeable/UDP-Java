# Injection in the context of Minecraft

Standard Minecraft cheating clients _(hacked clients)_ have been typically produced up until recently through Minecraft Coder Pack _(mcp)_, a tool that decompiles the game and allows you to recompile your modifications. This approach let developers work with the full source code of the game and provided tools to make deployment of their final product easy. However clients built from this design would commonly be exported in such a way that makes it clear the client is not vanilla or another common distribution such as forge. For a long time nobody seemed to care; cheating was all about who could be the most offensive in breaking the rules of the game. That has since changed.

## Motiviation

A few popular servers have employed the practice of screen-sharing to detect cheaters. This is typically done by looking at the Minecraft folder and checking for something obvious like hack config files, or even a version in the versions folder labeled _"nodus", "wolfram"_ or any other popular cheat. The clear solution to this is to not leave any traces. But then, how do you add your cheat to the game without modifying the code? Well, you don’t. You just change when you modify the code. 

## Injection: _A Primer_

What is injection in the context of Java? When you run a java program the virtual machine loads the class that contains the main method _(specified in the manifest or via vm argument)_. Every class that the main class references is then loaded. Every class it references is loaded, etc. Injection comes in two flavors, startup and runtime. In the case of startup when a class is referenced and loaded the bytecode of the class is passed to your injection agent via the Instrumentation API.  Your agent can make any modifications and then send back the modified bytecode to the virtual machine to load. The runtime version has all the same capabilities but instead you need to declare which classes you want to modify. Changes made to the methods in these classes are withheld until they are not included anywhere in the stack. For example, you cannot instrument the main method since it is always in the call-stack. In most games the same rule would disallow you from editing the game loop method _(but anything that it calls is fair game)_.

## Injection: _Does it solve the detection problem?_

Yes and no. If the client is written explicitly to not produce logging, configs, visuals, etc. then the standard peek into the Minecraft directory is resolved. No changes to the file-system are made thus it looks like a wholesome vanilla install. However you can still detect changes to the game by looking at the process itself. The easiest thing to check for are strings _([Fridump](https://github.com/Nightbringer21/fridump) is good for this)_ that don’t belong in vanilla Minecraft. A proper string dump of even a simple program can be stupidly large _(200,000 lines)_ but when you inject it gets even worse _(same program increased to 400,000 lines)_. Even though the dumped data is plentiful it only takes one search for `(Ljava/lang/String;Ljava/lang/instrument/Instrumentation;)V` to prove beyond a doubt that an injection agent has been used _(unless it is a forge client since forge uses some instrumentation)_. There are dozens of other literals specific to the instrumentation API that can be used, but this one is important since it represents the method declaration used to instantiate a java agent. 

## Injection: _If not for undetectability, then what?_

Injection allows you to be true to the java motto of _"write once, run anywhere"_ in the way of being able to have the same code work for any version of the game _(exception being version-specific features)_. For example a fly-hack that is based only off of motion x, y, and z will work as far back as there are motion fields in the entity class _(hint: basically every release to-date)_. The only component of an injection client that should need changes between versions is the mapping differences between versions. For instance if you open Minecraft and look in the class `net/minecraft/client/main/Main` the obfuscated name that represents the familiar `net/minecraft/client/Minecraft` is different on all versions. The structure of the class rarely changes between versions, it’s just the names.